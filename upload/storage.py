from django.conf import settings
from django.core.signing import SignatureExpired, BadSignature
from django.core.exceptions import PermissionDenied, SuspiciousOperation
import json
# Mutable, named tuples
from recordtype import recordtype

# It's tempting to just store the form itself, and
# serialize/deserialize it using form.__class__ and
# form.__class__.__module__ attributes.  However, form classes
# created using, e.g., modelform_factory are created dynamically and
# can not be properly deserialized/imported from the class and module alone
FileSetToken = recordtype('FileSetToken', [
    'uid',  # the uid generated by the field
    'pks',  # pks for the m2m
    'field_label',
    'form_class_name',
    'form_module',
    'model_class_name',
    'model_module',
    ('max_filesize', None),
    ('min_filesize', None),
    ('max_files', None),
    ('mimetypes', None),
])


def make_token(uid, pks, form, field_label):
    """
    Convencience method for constructing a FileSetToken
    """

    field = form.fields[field_label]

    return FileSetToken(
        uid=uid,
        pks=pks,
        field_label=field_label,
        form_class_name=form.__class__.__name__,
        form_module=form.__module__,
        model_class_name=field.queryset.model.__name__,
        model_module=field.queryset.model.__module__,
        max_filesize=getattr(field, 'max_filesize', None),
        min_filesize=getattr(field, 'min_filesize', None),
        max_files=getattr(field, 'max_files', None),
        mimetypes=getattr(field, 'mimetypes', None),
    )


class BaseStorage(object):
    """
    Stores/loads fileset auth tokesn from a cookie
    """
    prefix = 'upload_token_'

    def __init__(self, request, *args, **kwargs):
        self.request = request
        super(BaseStorage, self).__init__(*args, **kwargs)

    def _get(self, key, *args, **kwargs):
        raise NotImplementedError()

    def _store(self, token, response=None):
        raise NotImplementedError()


# class TokenEncoder(json.JSONEncoder):
#     def default(self, obj):
#         if not isinstance(obj, FileSetToken):
#             raise TypeError('Encoder must be passed a FileSetToken recordtype')
#         return super(TokenEncoder, self).default([v for v in obj])
# 
# 
# class TokenDecoder(json.JSONDecoder):
# 
#     def __init__(self):
#         json.JSONDecoder.__init__(self, object_hook=self.list_to_object)
# 
#     def list_to_object(self, l):
#         args = [v for v in l]
#         return FileSetToken(*args)

class SessionStorage(BaseStorage):
    prefix = '_uploads'

    def _get(self, key, *args, **kwargs):
        key = ''.join((self.prefix, key))
        return self.request.session.get(key)

    def _store(self, tokens, *args, **kwargs):
        for token in tokens:
            key = ''.join((self.prefix, token.uid))
            self.request.session[key] = token

    def _remove(self, tokens, response, *args, **kwargs):
        for token in tokens:
            key = ''.join((self.prefix, token.uid))
            self.request.session.pop(key, None)


class CookieStorage(BaseStorage):
    """
    Stores/loads fileset auth tokesn from a cookie
    """

    # Seconds of inactivity between request and response
    max_cookie_age = getattr(settings, 'MULTIUPLOADER_SESSION_TIMEOUT', 300)

    # I don't like this, but its the best I could come up with so far.
    # Currently, if we set the cookie to expire at max_cookie age,
    # there's no easy way to tell if the user's cookie expired or if
    # they are trying to access a page directly without first recieving
    # a cookie.  To provide more helpful http 403 messages, you can set
    # MULTIUPLOADER_COOKIE_LIFETIME to None, causing the cookie to
    # expire on browser close.  max_cookie_age will still be verfied
    # when loading the cookie, and this module will try to delete
    # cookies on a succceful POST to the parent model.  However, some
    # browsers are limited to as little as 20 cookies per domain, which
    # could be limiting if the user initates/abandones a number of
    # upload sessions.
    cookie_lifetime = getattr(settings, 'MULTIUPLOADER_COOKIE_LIFETIME',
                              max_cookie_age)
    def _get(self, key, request, max_age=max_cookie_age):
        # Check that cookies are enabled
        if ''.join((self.prefix, 'TEST')) not in request.COOKIES:
            cookies_enabled = False
        else:
            cookies_enabled = True
        if not cookies_enabled:
            raise PermissionDenied(('You must have cookies enabled to access '
                                    'this resource'))
        key = ''.join((self.prefix, key))
        try:
            cookie = request.get_signed_cookie(key, salt=key, max_age=max_age)
        except KeyError:
            # Kind of annoying. With the optional setting
            # MULTIUPLOADER_COOKIE_LIFETIMe, you can set  the cookies to not
            # expire until browser close, and just verify max_age when loading
            # the cookie.  However, some browsers restrict us to 20 cookies per
            # domain, which could be limiting if abandoned upload cookies
            # aren't expiring.
            raise PermissionDenied(('Sorry, either your session has expired '
                'or you do not have permission to acess this resource. Please '
                'refresh this page and try again.'))
        except SignatureExpired:
            # propbably shouldn't raise permission denied, but return a session
            # expired page.
            raise PermissionDenied(('Session has expired, please refresh this '
                                    'page and try again'))
        except BadSignature:
            raise SuspiciousOperation('Fileset token with key %s was tampered'
                                       % key)       

        return FileSetToken(*json.loads(cookie))

    def _store(self, tokens, response, request):
        # If session framework is installed, use it's test cookie facilities to
        # determine if cookies are enabled.  Otherwise, set our own test cookie
        if ''.join((self.prefix, 'TEST')) not in request.COOKIES:
                response.set_cookie(key=''.join((self.prefix, 'TEST')),
                                    value='worked')

        for token in tokens:
            key = ''.join((self.prefix, token.uid))
            #pythons cookie class requires an ascii key
            if type(key) == unicode:
                key = key.encode('ascii')
            encoded = json.dumps([v for v in token])
            #encoded = json.dumps(token._asdict())
            response.set_signed_cookie(key=key, value=encoded, salt=key,
                                       max_age=self.cookie_lifetime)
    def remove(self, tokens, response):
        for token in tokens:
            key = ''.join((self.prefix, token.uid))
            #pythons cookie class requires an ascii key
            if type(key) == unicode:
                key = key.encode('ascii')
            response.delete_cookie(key)
