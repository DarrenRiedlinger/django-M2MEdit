from django import forms
from django.core.urlresolvers import reverse
from django.utils.safestring import mark_safe
from django.core import validators
from upload.models import File
import uuid


# class MultiUploaderWidget(forms.widgets.HiddenInput):
#     # Not yet implemented
#     def render(self, name, value, attrs=None):
#         import ipdb; ipdb.set_trace()
#         url = reverse('edit_fileset', kwargs={'pk': value},
#                       current_app='upload')
#         output = u'<div><iframe src="%s"></iframe></div>' % url
#         hidden_input = super(MultiUploaderWidget, self).render(name,
#                                                         value, attrs=attrs)
#         return mark_safe('\n'.join((output, hidden_input)))
class MultiUploaderIframeWidget(forms.widgets.MultiWidget):
    """
    A widget that renders:
        --an iframe with a link to our fileupload form
        --a hidden charfield containing a list of selected files
    """
    def __init__(self, attrs=None, choices=()):
        import ipdb; ipdb.set_trace()
        widgets = (
            forms.widgets.TextInput(attrs=attrs),
            forms.widgets.SelectMultiple(attrs=attrs, choices=choices),
        )
        super(MultiUploaderIframeWidget, self).__init__(widgets, attrs)

    def render(self, name, value, attrs=None):
        """
        Overiding forms.widgets.MultiWidget to always decompress
        """
        import ipdb; ipdb.set_trace()
        if self.is_localized:
            for widget in self.widgets:
                widget.is_localized = self.is_localized
        # value is a list of values, each corresponding to a widget
        # in self.widgets.
        value = self.decompress(value)
        output = []
        final_attrs = self.build_attrs(attrs)
        id_ = final_attrs.get('id', None)
        for i, widget in enumerate(self.widgets):
            try:
                widget_value = value[i]
            except IndexError:
                widget_value = None
            if id_:
                final_attrs = dict(final_attrs, id='%s_%s' % (id_, i))
            output.append(widget.render(name + '_%s' % i, widget_value,
                                        final_attrs))
        return mark_safe(self.format_output(output))

    def decompress(self, value):
        import ipdb; ipdb.set_trace()
        if value:
            return [value[0], value[1]]
        return [None, None]


class MultiUploaderField(forms.MultiValueField):
    """
    Contains a charfield with an autogenerated uuid and a
    ModelMultipleChoiceField.
    """

    def __init__(self, queryset, *args, **kwargs):
        import ipdb; ipdb.set_trace()
        if not queryset:
            queryset=File.objects.all()
        initial = getattr(kwargs, 'initial', None)
        if not initial:
            kwargs['initial'] = [uuid.uuid4().hex, None]
        fields = (
            forms.CharField(),
            forms.ModelMultipleChoiceField(queryset=queryset),
        )
        choices = fields[1]._get_choices()
        widget = MultiUploaderIframeWidget(choices=choices)
        super(MultiUploaderField, self).__init__(fields, widget=widget,
                                                 *args, **kwargs)
    # def clean(self, value):
    #     """
    #     Validates every value in the given list. A value is validated againsi
    #     the corresponding Field in self.fields.

    #     For example, if this MultiValueField was instantiated with
    #     fields=(DateField(), TimeField()), clean() would call
    #     DateField.clean(value[0]) and TimeField.clean(value[1]).
    #     """
    #     clean_data = []
    #     errors = ErrorList()
    #     if not value or isinstance(value, (list, tuple)):
    #         if not value or not [v for v in value if v not in validators.EMPTY_VALUES]:
    #             if self.required:
    #                 raise ValidationError(self.error_messages['required'])
    #             else:
    #                 return self.compress([])
    #     else:
    #         raise ValidationError(self.error_messages['invalid'])
    #     for i, field in enumerate(self.fields):
    #         try:
    #             field_value = value[i]
    #         except IndexError:
    #             field_value = None
    #         if self.required and field_value in validators.EMPTY_VALUES:
    #             raise ValidationError(self.error_messages['required'])
    #         try:
    #             clean_data.append(field.clean(field_value))
    #         except ValidationError, e:
    #             # Collect all validation errors in a single list, which we'll
    #             # raise at the end of clean(), rather than raising a single
    #             # exception for the first error we encounter.
    #             errors.extend(e.messages)
    #     if errors:
    #         raise ValidationError(errors)
    #     
    #     out = self.compress(clean_data)
    #     self.validate(out)
    #     self.run_validators(out)
        
    def compress(self, data_list):
        import ipdb; ipdb.set_trace()
        if data_list:
            return data_list[1]
        return None

    def to_python(self, value):
        import ipdb; ipdb.set_trace()
        super(MultiUploaderField, self).to_python(value)
# class MultiUploaderField(forms.ModelChoiceField):
#     """
#     A ModelChoiceField in which 'initial' defaults to a unique id
#     """
#     widget = MultiUploaderWidget
# 
#     @property
#     def initial(self):
#         if not self._initial:
#             self._initial = uuid.uuid4().hex
#         return self._initial
# 
#     @initial.setter
#     def initial(self, value):
#         self._initial = value
